{
  "version": 3,
  "sources": ["../../@dfinity/identity/src/identity/ed25519.ts", "../../@dfinity/identity/src/identity/ecdsa.ts", "../../@dfinity/identity/src/identity/partial.ts", "../../@dfinity/identity/src/identity/delegation.ts", "../../@dfinity/identity/src/identity/webauthn.ts", "../../@dfinity/auth-client/src/idleManager.ts", "../../idb/build/wrap-idb-value.js", "../../idb/build/index.js", "../../@dfinity/auth-client/src/db.ts", "../../@dfinity/auth-client/src/storage.ts", "../../@dfinity/auth-client/src/index.ts"],
  "sourcesContent": ["import {\n  type DerEncodedPublicKey,\n  type KeyPair,\n  type PublicKey,\n  type Signature,\n  SignIdentity,\n  ED25519_OID,\n  unwrapDER,\n  wrapDER,\n} from '@dfinity/agent';\nimport { uint8Equals, uint8FromBufLike } from '@dfinity/candid';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\ndeclare type KeyLike = PublicKey | DerEncodedPublicKey | ArrayBuffer | ArrayBufferView;\n\nfunction isObject(value: unknown) {\n  return value !== null && typeof value === 'object';\n}\n\nexport class Ed25519PublicKey implements PublicKey {\n  /**\n   * Construct Ed25519PublicKey from an existing PublicKey\n   * @param {unknown} maybeKey - existing PublicKey, ArrayBuffer, DerEncodedPublicKey, or hex string\n   * @returns {Ed25519PublicKey} Instance of Ed25519PublicKey\n   */\n  public static from(maybeKey: unknown): Ed25519PublicKey {\n    if (typeof maybeKey === 'string') {\n      const key = hexToBytes(maybeKey);\n      return this.fromRaw(key);\n    } else if (isObject(maybeKey)) {\n      const key = maybeKey as KeyLike;\n      if (isObject(key) && Object.hasOwnProperty.call(key, '__derEncodedPublicKey__')) {\n        return this.fromDer(key as DerEncodedPublicKey);\n      } else if (ArrayBuffer.isView(key)) {\n        const view = key as ArrayBufferView;\n        return this.fromRaw(uint8FromBufLike(view.buffer));\n      } else if (key instanceof ArrayBuffer) {\n        return this.fromRaw(uint8FromBufLike(key));\n      } else if ('rawKey' in key && key.rawKey instanceof Uint8Array) {\n        return this.fromRaw(key.rawKey);\n      } else if ('derKey' in key) {\n        return this.fromDer(key.derKey as DerEncodedPublicKey);\n      } else if ('toDer' in key) {\n        return this.fromDer(key.toDer());\n      }\n    }\n    throw new Error('Cannot construct Ed25519PublicKey from the provided key.');\n  }\n\n  public static fromRaw(rawKey: Uint8Array): Ed25519PublicKey {\n    return new Ed25519PublicKey(rawKey);\n  }\n\n  public static fromDer(derKey: DerEncodedPublicKey): Ed25519PublicKey {\n    return new Ed25519PublicKey(this.derDecode(derKey));\n  }\n\n  // The length of Ed25519 public keys is always 32 bytes.\n  private static RAW_KEY_LENGTH = 32;\n\n  private static derEncode(publicKey: Uint8Array): DerEncodedPublicKey {\n    const key = wrapDER(publicKey, ED25519_OID) as DerEncodedPublicKey;\n    key.__derEncodedPublicKey__ = undefined;\n    return key;\n  }\n\n  private static derDecode(key: DerEncodedPublicKey): Uint8Array {\n    const unwrapped = unwrapDER(key, ED25519_OID);\n    if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    return unwrapped;\n  }\n\n  #rawKey: Uint8Array;\n\n  public get rawKey(): Uint8Array {\n    return this.#rawKey;\n  }\n\n  #derKey: DerEncodedPublicKey;\n\n  public get derKey(): DerEncodedPublicKey {\n    return this.#derKey;\n  }\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  private constructor(key: Uint8Array) {\n    if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    this.#rawKey = key;\n    this.#derKey = Ed25519PublicKey.derEncode(key);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this.derKey;\n  }\n\n  public toRaw(): Uint8Array {\n    return this.rawKey;\n  }\n}\n\n/**\n * Ed25519KeyIdentity is an implementation of SignIdentity that uses Ed25519 keys. This class is used to sign and verify messages for an agent.\n */\nexport class Ed25519KeyIdentity extends SignIdentity {\n  /**\n   * Generate a new Ed25519KeyIdentity.\n   * @param seed a 32-byte seed for the private key. If not provided, a random seed will be generated.\n   * @returns Ed25519KeyIdentity\n   */\n  public static generate(seed?: Uint8Array): Ed25519KeyIdentity {\n    if (seed && seed.length !== 32) {\n      throw new Error('Ed25519 Seed needs to be 32 bytes long.');\n    }\n    if (!seed) seed = ed25519.utils.randomPrivateKey();\n    // Check if the seed is all zeros\n    if (uint8Equals(seed, new Uint8Array(new Array(32).fill(0)))) {\n      console.warn(\n        'Seed is all zeros. This is not a secure seed. Please provide a seed with sufficient entropy if this is a production environment.',\n      );\n    }\n    const sk = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) {\n      sk[i] = seed[i];\n    }\n\n    const pk = ed25519.getPublicKey(sk);\n    return Ed25519KeyIdentity.fromKeyPair(pk, sk);\n  }\n\n  public static fromParsedJson(obj: JsonnableEd25519KeyIdentity): Ed25519KeyIdentity {\n    const [publicKeyDer, privateKeyRaw] = obj;\n    return new Ed25519KeyIdentity(\n      Ed25519PublicKey.fromDer(hexToBytes(publicKeyDer) as DerEncodedPublicKey),\n      hexToBytes(privateKeyRaw),\n    );\n  }\n\n  public static fromJSON(json: string): Ed25519KeyIdentity {\n    const parsed = JSON.parse(json);\n    if (Array.isArray(parsed)) {\n      if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n        return this.fromParsedJson([parsed[0], parsed[1]]);\n      } else {\n        throw new Error('Deserialization error: JSON must have at least 2 items.');\n      }\n    }\n    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n  }\n\n  public static fromKeyPair(publicKey: Uint8Array, privateKey: Uint8Array): Ed25519KeyIdentity {\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);\n  }\n\n  public static fromSecretKey(secretKey: Uint8Array): Ed25519KeyIdentity {\n    const publicKey = ed25519.getPublicKey(secretKey);\n    return Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);\n  }\n\n  #publicKey: Ed25519PublicKey;\n  #privateKey: Uint8Array;\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  protected constructor(publicKey: PublicKey, privateKey: Uint8Array) {\n    super();\n    this.#publicKey = Ed25519PublicKey.from(publicKey);\n    this.#privateKey = privateKey;\n  }\n\n  /**\n   * Serialize this key to JSON.\n   */\n  public toJSON(): JsonnableEd25519KeyIdentity {\n    return [bytesToHex(this.#publicKey.toDer()), bytesToHex(this.#privateKey)];\n  }\n\n  /**\n   * Return a copy of the key pair.\n   */\n  public getKeyPair(): KeyPair {\n    return {\n      secretKey: this.#privateKey,\n      publicKey: this.#publicKey,\n    };\n  }\n\n  /**\n   * Return the public key.\n   */\n  public getPublicKey(): Required<PublicKey> {\n    return this.#publicKey;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param challenge - challenge to sign with this identity's secretKey, producing a signature\n   */\n  public async sign(challenge: Uint8Array): Promise<Signature> {\n    // Some implementations of Ed25519 private keys append a public key to the end of the private key. We only want the private key.\n    const signature = ed25519.sign(challenge, this.#privateKey.slice(0, 32));\n    // add { __signature__: void; } to the signature to make it compatible with the agent\n\n    Object.defineProperty(signature, '__signature__', {\n      enumerable: false,\n      value: undefined,\n    });\n\n    return signature as Signature;\n  }\n\n  /**\n   * Verify\n   * @param sig - signature to verify\n   * @param msg - message to verify\n   * @param pk - public key\n   * @returns - true if the signature is valid, false otherwise\n   */\n  public static verify(\n    sig: ArrayBuffer | Uint8Array | string,\n    msg: ArrayBuffer | Uint8Array | string,\n    pk: ArrayBuffer | Uint8Array | string,\n  ) {\n    const [signature, message, publicKey] = [sig, msg, pk].map(x => {\n      if (typeof x === 'string') {\n        x = hexToBytes(x);\n      }\n      return uint8FromBufLike(x);\n    });\n    return ed25519.verify(signature, message, publicKey);\n  }\n}\n\ntype PublicKeyHex = string;\ntype SecretKeyHex = string;\nexport type JsonnableEd25519KeyIdentity = [PublicKeyHex, SecretKeyHex];\n", "import {\n  type DerEncodedPublicKey,\n  type PublicKey,\n  type Signature,\n  SignIdentity,\n} from '@dfinity/agent';\nimport { uint8FromBufLike } from '@dfinity/candid';\n\n/**\n * Options used in a {@link ECDSAKeyIdentity}\n */\nexport type CryptoKeyOptions = {\n  extractable?: boolean;\n  keyUsages?: KeyUsage[];\n  subtleCrypto?: SubtleCrypto;\n};\n\nexport class CryptoError extends Error {\n  constructor(public readonly message: string) {\n    super(message);\n    Object.setPrototypeOf(this, CryptoError.prototype);\n  }\n}\n\nexport interface DerCryptoKey extends CryptoKey {\n  toDer: () => DerEncodedPublicKey;\n}\n\n/**\n * Utility method to ensure that a subtleCrypto implementation is provided or is available in the global context\n * @param subtleCrypto SubtleCrypto implementation\n * @returns subleCrypto\n */\nfunction _getEffectiveCrypto(subtleCrypto: CryptoKeyOptions['subtleCrypto']): SubtleCrypto {\n  if (typeof global !== 'undefined' && global['crypto'] && global['crypto']['subtle']) {\n    return global['crypto']['subtle'];\n  }\n  if (subtleCrypto) {\n    return subtleCrypto;\n  } else if (typeof crypto !== 'undefined' && crypto['subtle']) {\n    return crypto.subtle;\n  } else {\n    throw new CryptoError(\n      'Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto',\n    );\n  }\n}\n\n/**\n * An identity interface that wraps an ECDSA keypair using the P-256 named curve. Supports DER-encoding and decoding for agent calls\n */\nexport class ECDSAKeyIdentity extends SignIdentity {\n  /**\n   * Generates a randomly generated identity for use in calls to the Internet Computer.\n   * @param {CryptoKeyOptions} options optional settings\n   * @param {CryptoKeyOptions['extractable']} options.extractable - whether the key should allow itself to be used. Set to false for maximum security.\n   * @param {CryptoKeyOptions['keyUsages']} options.keyUsages - a list of key usages that the key can be used for\n   * @param {CryptoKeyOptions['subtleCrypto']} options.subtleCrypto interface\n   * @returns a {@link ECDSAKeyIdentity}\n   */\n  public static async generate(options?: CryptoKeyOptions): Promise<ECDSAKeyIdentity> {\n    const { extractable = false, keyUsages = ['sign', 'verify'], subtleCrypto } = options ?? {};\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const keyPair = await effectiveCrypto.generateKey(\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n      },\n      extractable,\n      keyUsages,\n    );\n    const derKey: DerEncodedPublicKey = uint8FromBufLike(\n      await effectiveCrypto.exportKey('spki', keyPair.publicKey),\n    );\n\n    Object.assign(derKey, {\n      __derEncodedPublicKey__: undefined,\n    });\n\n    return new this(keyPair, derKey, effectiveCrypto);\n  }\n\n  /**\n   * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key\n   * @param keyPair a CryptoKeyPair\n   * @param subtleCrypto - a SubtleCrypto interface in case one is not available globally\n   * @returns an {@link ECDSAKeyIdentity}\n   */\n  public static async fromKeyPair(\n    keyPair: CryptoKeyPair | { privateKey: CryptoKey; publicKey: CryptoKey },\n    subtleCrypto?: SubtleCrypto,\n  ): Promise<ECDSAKeyIdentity> {\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const derKey: DerEncodedPublicKey = uint8FromBufLike(\n      await effectiveCrypto.exportKey('spki', keyPair.publicKey),\n    );\n    Object.assign(derKey, {\n      __derEncodedPublicKey__: undefined,\n    });\n    return new ECDSAKeyIdentity(keyPair, derKey, effectiveCrypto);\n  }\n\n  protected _derKey: DerEncodedPublicKey;\n  protected _keyPair: CryptoKeyPair;\n  protected _subtleCrypto: SubtleCrypto;\n\n  // `fromKeyPair` and `generate` should be used for instantiation, not this constructor.\n  protected constructor(\n    keyPair: CryptoKeyPair,\n    derKey: DerEncodedPublicKey,\n    subtleCrypto: SubtleCrypto,\n  ) {\n    super();\n    this._keyPair = keyPair;\n    this._derKey = derKey;\n    this._subtleCrypto = subtleCrypto;\n  }\n\n  /**\n   * Return the internally-used key pair.\n   * @returns a CryptoKeyPair\n   */\n  public getKeyPair(): CryptoKeyPair {\n    return this._keyPair;\n  }\n\n  /**\n   * Return the public key.\n   * @returns an {@link PublicKey & DerCryptoKey}\n   */\n  public getPublicKey(): PublicKey & DerCryptoKey {\n    const derKey = this._derKey;\n    const key: DerCryptoKey = Object.create(this._keyPair.publicKey);\n    key.toDer = function () {\n      return derKey;\n    };\n\n    return key;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param {Uint8Array} challenge - challenge to sign with this identity's secretKey, producing a signature\n   * @returns {Promise<Signature>} signature\n   */\n  public async sign(challenge: Uint8Array): Promise<Signature> {\n    const params: EcdsaParams = {\n      name: 'ECDSA',\n      hash: { name: 'SHA-256' },\n    };\n    const signature = uint8FromBufLike(\n      await this._subtleCrypto.sign(params, this._keyPair.privateKey, challenge),\n    );\n\n    Object.assign(signature, {\n      __signature__: undefined,\n    });\n\n    return signature as Signature;\n  }\n}\n\nexport default ECDSAKeyIdentity;\n", "import { type Identity, type PublicKey } from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\n\n/**\n * A partial delegated identity, representing a delegation chain and the public key that it targets\n */\nexport class PartialIdentity implements Identity {\n  #inner: PublicKey;\n\n  /**\n   * The raw public key of this identity.\n   */\n  get rawKey(): Uint8Array | undefined {\n    return this.#inner.rawKey;\n  }\n\n  /**\n   * The DER-encoded public key of this identity.\n   */\n  get derKey(): Uint8Array | undefined {\n    return this.#inner.derKey;\n  }\n\n  /**\n   * The DER-encoded public key of this identity.\n   */\n  public toDer(): Uint8Array {\n    return this.#inner.toDer();\n  }\n\n  /**\n   * The inner {@link PublicKey} used by this identity.\n   */\n  public getPublicKey(): PublicKey {\n    return this.#inner;\n  }\n\n  /**\n   * The {@link Principal} of this identity.\n   */\n  public getPrincipal(): Principal {\n    if (!this.#inner.rawKey) {\n      throw new Error('Cannot get principal from a public key without a raw key.');\n    }\n    return Principal.fromUint8Array(new Uint8Array(this.#inner.rawKey));\n  }\n\n  /**\n   * Required for the Identity interface, but cannot implemented for just a public key.\n   */\n  public transformRequest(): Promise<never> {\n    return Promise.reject(\n      'Not implemented. You are attempting to use a partial identity to sign calls, but this identity only has access to the public key.To sign calls, use a DelegationIdentity instead.',\n    );\n  }\n\n  constructor(inner: PublicKey) {\n    this.#inner = inner;\n  }\n}\n", "import {\n  type DerEncodedPublicKey,\n  type HttpAgentRequest,\n  type PublicKey,\n  requestIdOf,\n  type Signature,\n  SignIdentity,\n  IC_REQUEST_DOMAIN_SEPARATOR,\n  IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR,\n  ToCborValue,\n} from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\nimport { PartialIdentity } from './partial.ts';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\n/**\n * Safe wrapper around bytesToHex that handles ArrayBuffer/Uint8Array type conversion.\n * Required because @noble/hashes v1.8+ strictly expects Uint8Array inputs.\n * @param data The binary data to convert to hexadecimal string (ArrayBuffer, Uint8Array, or ArrayLike<number>)\n */\nfunction safeBytesToHex(data: ArrayBuffer | Uint8Array | ArrayLike<number>): string {\n  if (data instanceof Uint8Array) {\n    return bytesToHex(data);\n  }\n  return bytesToHex(new Uint8Array(data));\n}\n\nfunction _parseBlob(value: unknown): Uint8Array {\n  if (typeof value !== 'string' || value.length < 64) {\n    throw new Error('Invalid public key.');\n  }\n\n  return hexToBytes(value);\n}\n\n/**\n * A single delegation object that is signed by a private key. This is constructed by\n * `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport class Delegation implements ToCborValue {\n  constructor(\n    public readonly pubkey: Uint8Array,\n    public readonly expiration: bigint,\n    public readonly targets?: Principal[],\n  ) {}\n\n  public toCborValue() {\n    return {\n      pubkey: this.pubkey,\n      expiration: this.expiration,\n      ...(this.targets && {\n        targets: this.targets,\n      }),\n    };\n  }\n\n  public toJSON(): JsonnableDelegation {\n    // every string should be hex and once-de-hexed,\n    // discoverable what it is (e.g. de-hex to get JSON with a 'type' property, or de-hex to DER\n    // with an OID). After de-hex, if it's not obvious what it is, it's an ArrayBuffer.\n    return {\n      expiration: this.expiration.toString(16),\n      pubkey: safeBytesToHex(this.pubkey),\n      ...(this.targets && { targets: this.targets.map(p => p.toHex()) }),\n    };\n  }\n}\n\n/**\n * Type of ReturnType<Delegation.toJSON>.\n * The goal here is to stringify all non-JSON-compatible types to some bytes representation we can\n * stringify as hex.\n * (Hex shouldn't be ambiguous ever, because you can encode as DER with semantic OIDs).\n */\ninterface JsonnableDelegation {\n  // A BigInt of Nanoseconds since epoch as hex\n  expiration: string;\n  // Hexadecimal representation of the DER public key.\n  pubkey: string;\n  // Array of strings, where each string is hex of principal blob (*NOT* textual representation).\n  targets?: string[];\n}\n\n/**\n * A signed delegation, which lends its identity to the public key in the delegation\n * object. This is constructed by `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport interface SignedDelegation {\n  delegation: Delegation;\n  signature: Signature;\n}\n\n/**\n * Sign a single delegation object for a period of time.\n * @param from The identity that lends its delegation.\n * @param to The identity that receives the delegation.\n * @param expiration An expiration date for this delegation.\n * @param targets Limit this delegation to the target principals.\n */\nasync function _createSingleDelegation(\n  from: SignIdentity,\n  to: PublicKey,\n  expiration: Date,\n  targets?: Principal[],\n): Promise<SignedDelegation> {\n  const delegation: Delegation = new Delegation(\n    to.toDer(),\n    BigInt(+expiration) * BigInt(1000000), // In nanoseconds.\n    targets,\n  );\n  // The signature is calculated by signing the concatenation of the domain separator\n  // and the message.\n  // Note: To ensure Safari treats this as a user gesture, ensure to not use async methods\n  // besides the actualy webauthn functionality (such as `sign`). Safari will de-register\n  // a user gesture if you await an async call thats not fetch, xhr, or setTimeout.\n  const challenge = new Uint8Array([\n    ...IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR,\n    ...new Uint8Array(requestIdOf({ ...delegation })),\n  ]);\n  const signature = await from.sign(challenge);\n\n  return {\n    delegation,\n    signature,\n  };\n}\n\nexport interface JsonnableDelegationChain {\n  publicKey: string;\n  delegations: Array<{\n    signature: string;\n    delegation: {\n      pubkey: string;\n      expiration: string;\n      targets?: string[];\n    };\n  }>;\n}\n\n/**\n * A chain of delegations. This is JSON Serializable.\n * This is the object to serialize and pass to a DelegationIdentity. It does not keep any\n * private keys.\n */\nexport class DelegationChain {\n  /**\n   * Create a delegation chain between two (or more) keys. By default, the expiration time\n   * will be very short (15 minutes).\n   *\n   * To build a chain of more than 2 identities, this function needs to be called multiple times,\n   * passing the previous delegation chain into the options argument. For example:\n   * @example\n   * const rootKey = createKey();\n   * const middleKey = createKey();\n   * const bottomeKey = createKey();\n   *\n   * const rootToMiddle = await DelegationChain.create(\n   *   root, middle.getPublicKey(), Date.parse('2100-01-01'),\n   * );\n   * const middleToBottom = await DelegationChain.create(\n   *   middle, bottom.getPublicKey(), Date.parse('2100-01-01'), { previous: rootToMiddle },\n   * );\n   *\n   * // We can now use a delegation identity that uses the delegation above:\n   * const identity = DelegationIdentity.fromDelegation(bottomKey, middleToBottom);\n   * @param from The identity that will delegate.\n   * @param to The identity that gets delegated. It can now sign messages as if it was the\n   *           identity above.\n   * @param expiration The length the delegation is valid. By default, 15 minutes from calling\n   *                   this function.\n   * @param options A set of options for this delegation. expiration and previous\n   * @param options.previous - Another DelegationChain that this chain should start with.\n   * @param options.targets - targets that scope the delegation (e.g. Canister Principals)\n   */\n  public static async create(\n    from: SignIdentity,\n    to: PublicKey,\n    expiration: Date = new Date(Date.now() + 15 * 60 * 1000),\n    options: {\n      previous?: DelegationChain;\n      targets?: Principal[];\n    } = {},\n  ): Promise<DelegationChain> {\n    const delegation = await _createSingleDelegation(from, to, expiration, options.targets);\n    return new DelegationChain(\n      [...(options.previous?.delegations || []), delegation],\n      options.previous?.publicKey || from.getPublicKey().toDer(),\n    );\n  }\n\n  /**\n   * Creates a DelegationChain object from a JSON string.\n   * @param json The JSON string to parse.\n   */\n  public static fromJSON(json: string | JsonnableDelegationChain): DelegationChain {\n    const { publicKey, delegations } = typeof json === 'string' ? JSON.parse(json) : json;\n    if (!Array.isArray(delegations)) {\n      throw new Error('Invalid delegations.');\n    }\n\n    const parsedDelegations: SignedDelegation[] = delegations.map(signedDelegation => {\n      const { delegation, signature } = signedDelegation;\n      const { pubkey, expiration, targets } = delegation;\n      if (targets !== undefined && !Array.isArray(targets)) {\n        throw new Error('Invalid targets.');\n      }\n\n      return {\n        delegation: new Delegation(\n          _parseBlob(pubkey),\n          BigInt('0x' + expiration), // expiration in JSON is an hexa string (See toJSON() below).\n          targets &&\n            targets.map((t: unknown) => {\n              if (typeof t !== 'string') {\n                throw new Error('Invalid target.');\n              }\n              return Principal.fromHex(t);\n            }),\n        ),\n        signature: _parseBlob(signature) as Signature,\n      };\n    });\n\n    return new this(parsedDelegations, _parseBlob(publicKey) as DerEncodedPublicKey);\n  }\n\n  /**\n   * Creates a DelegationChain object from a list of delegations and a DER-encoded public key.\n   * @param delegations The list of delegations.\n   * @param publicKey The DER-encoded public key of the key-pair signing the first delegation.\n   */\n  public static fromDelegations(\n    delegations: SignedDelegation[],\n    publicKey: DerEncodedPublicKey,\n  ): DelegationChain {\n    return new this(delegations, publicKey);\n  }\n\n  protected constructor(\n    public readonly delegations: SignedDelegation[],\n    public readonly publicKey: DerEncodedPublicKey,\n  ) {}\n\n  public toJSON(): JsonnableDelegationChain {\n    return {\n      delegations: this.delegations.map(signedDelegation => {\n        const { delegation, signature } = signedDelegation;\n        const { targets } = delegation;\n        return {\n          delegation: {\n            expiration: delegation.expiration.toString(16),\n            pubkey: safeBytesToHex(delegation.pubkey),\n            ...(targets && {\n              targets: targets.map(t => t.toHex()),\n            }),\n          },\n          signature: safeBytesToHex(signature),\n        };\n      }),\n      publicKey: safeBytesToHex(this.publicKey),\n    };\n  }\n}\n\n/**\n * An Identity that adds delegation to a request. Everywhere in this class, the name\n * innerKey refers to the SignIdentity that is being used to sign the requests, while\n * originalKey is the identity that is being borrowed. More identities can be used\n * in the middle to delegate.\n */\nexport class DelegationIdentity extends SignIdentity {\n  /**\n   * Create a delegation without having access to delegateKey.\n   * @param key The key used to sign the requests.\n   * @param delegation A delegation object created using `createDelegation`.\n   */\n  public static fromDelegation(\n    key: Pick<SignIdentity, 'sign'>,\n    delegation: DelegationChain,\n  ): DelegationIdentity {\n    return new this(key, delegation);\n  }\n\n  protected constructor(\n    private _inner: Pick<SignIdentity, 'sign'>,\n    private _delegation: DelegationChain,\n  ) {\n    super();\n  }\n\n  public getDelegation(): DelegationChain {\n    return this._delegation;\n  }\n\n  public getPublicKey(): PublicKey {\n    return {\n      derKey: this._delegation.publicKey,\n      toDer: () => this._delegation.publicKey,\n    };\n  }\n  public sign(blob: Uint8Array): Promise<Signature> {\n    return this._inner.sign(blob);\n  }\n\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    const { body, ...fields } = request;\n    const requestId = await requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_sig: await this.sign(\n          new Uint8Array([...IC_REQUEST_DOMAIN_SEPARATOR, ...new Uint8Array(requestId)]),\n        ),\n        sender_delegation: this._delegation.delegations,\n        sender_pubkey: this._delegation.publicKey,\n      },\n    };\n  }\n}\n\n/**\n * A partial delegated identity, representing a delegation chain and the public key that it targets\n */\nexport class PartialDelegationIdentity extends PartialIdentity {\n  #delegation: DelegationChain;\n\n  /**\n   * The Delegation Chain of this identity.\n   */\n  get delegation(): DelegationChain {\n    return this.#delegation;\n  }\n\n  private constructor(inner: PublicKey, delegation: DelegationChain) {\n    super(inner);\n    this.#delegation = delegation;\n  }\n\n  /**\n   * Create a {@link PartialDelegationIdentity} from a {@link PublicKey} and a {@link DelegationChain}.\n   * @param key The {@link PublicKey} to delegate to.\n   * @param delegation a {@link DelegationChain} targeting the inner key.\n   */\n  public static fromDelegation(key: PublicKey, delegation: DelegationChain) {\n    return new PartialDelegationIdentity(key, delegation);\n  }\n}\n\n/**\n * List of things to check for a delegation chain validity.\n */\nexport interface DelegationValidChecks {\n  /**\n   * Check that the scope is amongst the scopes that this delegation has access to.\n   */\n  scope?: Principal | string | Array<Principal | string>;\n}\n\n/**\n * Analyze a DelegationChain and validate that it's valid, ie. not expired and apply to the\n * scope.\n * @param chain The chain to validate.\n * @param checks Various checks to validate on the chain.\n */\nexport function isDelegationValid(chain: DelegationChain, checks?: DelegationValidChecks): boolean {\n  // Verify that the no delegation is expired. If any are in the chain, returns false.\n  for (const { delegation } of chain.delegations) {\n    // prettier-ignore\n    if (+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now()) {\n      return false;\n    }\n  }\n\n  // Check the scopes.\n  const scopes: Principal[] = [];\n  const maybeScope = checks?.scope;\n  if (maybeScope) {\n    if (Array.isArray(maybeScope)) {\n      scopes.push(...maybeScope.map(s => (typeof s === 'string' ? Principal.fromText(s) : s)));\n    } else {\n      scopes.push(typeof maybeScope === 'string' ? Principal.fromText(maybeScope) : maybeScope);\n    }\n  }\n\n  for (const s of scopes) {\n    const scope = s.toText();\n    for (const { delegation } of chain.delegations) {\n      if (delegation.targets === undefined) {\n        continue;\n      }\n\n      let none = true;\n      for (const target of delegation.targets) {\n        if (target.toText() === scope) {\n          none = false;\n          break;\n        }\n      }\n      if (none) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n", "import {\n  type DerEncodedPublicKey,\n  type PublicKey,\n  type Signature,\n  SignIdentity,\n  wrapDER,\n  DER_COSE_OID,\n  Cbor,\n} from '@dfinity/agent';\nimport { bytesToHex, hexToBytes, randomBytes, bytesToUtf8 } from '@noble/hashes/utils';\nimport { uint8FromBufLike } from '@dfinity/candid';\n\nfunction _coseToDerEncodedBlob(cose: Uint8Array): DerEncodedPublicKey {\n  return wrapDER(cose, DER_COSE_OID) as DerEncodedPublicKey;\n}\n\ntype PublicKeyCredentialWithAttachment = PublicKeyCredential & {\n  // Extends `PublicKeyCredential` with an optional field introduced in the WebAuthn level 3 spec:\n  // https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment\n  // Already supported by Chrome, Safari and Edge\n  // Note: `null` is included here as a possible value because Edge set this value to null in the\n  // past.\n  authenticatorAttachment: AuthenticatorAttachment | undefined | null;\n  // Explicitly including toJSON method from the base PublicKeyCredential interface\n  toJSON: () => Record<string, unknown>;\n};\n\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData: Uint8Array): Uint8Array {\n  const dataView = new DataView(new ArrayBuffer(2));\n  const idLenBytes = authData.slice(53, 55);\n  [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n  const credentialIdLength = dataView.getUint16(0);\n\n  // Get the public key object.\n  return authData.slice(55 + credentialIdLength);\n}\n\nexport class CosePublicKey implements PublicKey {\n  protected _encodedKey: DerEncodedPublicKey;\n\n  public constructor(protected _cose: Uint8Array) {\n    this._encodedKey = _coseToDerEncodedBlob(_cose);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this._encodedKey;\n  }\n\n  public getCose(): Uint8Array {\n    return this._cose;\n  }\n}\n\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer(challenge: string | Uint8Array = '<ic0.app>'): Uint8Array {\n  if (typeof challenge === 'string') {\n    return Uint8Array.from(challenge, c => c.charCodeAt(0));\n  } else {\n    return challenge;\n  }\n}\n\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(\n  credentialCreationOptions?: CredentialCreationOptions,\n): Promise<PublicKeyCredentialWithAttachment | null> {\n  const creds = (await navigator.credentials.create(\n    credentialCreationOptions ?? {\n      publicKey: {\n        authenticatorSelection: {\n          userVerification: 'preferred',\n        },\n        attestation: 'direct',\n        challenge: _createChallengeBuffer(),\n        pubKeyCredParams: [{ type: 'public-key', alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256 }],\n        rp: {\n          name: 'Internet Identity Service',\n        },\n        user: {\n          id: randomBytes(16),\n          name: 'Internet Identity',\n          displayName: 'Internet Identity',\n        },\n      },\n    },\n  )) as PublicKeyCredentialWithAttachment | null;\n\n  if (creds === null) {\n    return null;\n  }\n\n  return {\n    // do _not_ use ...creds here, as creds is not enumerable in all cases\n    id: creds.id,\n    response: creds.response,\n    type: creds.type,\n    authenticatorAttachment: creds.authenticatorAttachment,\n    getClientExtensionResults: creds.getClientExtensionResults,\n    // Some password managers will return a Uint8Array, so we ensure we return an ArrayBuffer.\n    rawId: creds.rawId,\n    toJSON: creds.toJSON.bind(creds), // Ensure the toJSON method is included\n  };\n}\n\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nenum PubKeyCoseAlgo {\n  ECDSA_WITH_SHA256 = -7,\n}\n\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nexport class WebAuthnIdentity extends SignIdentity {\n  /**\n   * Create an identity from a JSON serialization.\n   * @param json - json to parse\n   */\n  public static fromJSON(json: string): WebAuthnIdentity {\n    const { publicKey, rawId } = JSON.parse(json);\n\n    if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n      throw new Error('Invalid JSON string.');\n    }\n\n    return new this(hexToBytes(rawId), hexToBytes(publicKey), undefined);\n  }\n\n  /**\n   * Create an identity.\n   * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n   */\n  public static async create(\n    credentialCreationOptions?: CredentialCreationOptions,\n  ): Promise<WebAuthnIdentity> {\n    const creds = await _createCredential(credentialCreationOptions);\n\n    if (!creds || creds.type !== 'public-key') {\n      throw new Error('Could not create credentials.');\n    }\n\n    const response = creds.response as AuthenticatorAttestationResponse;\n    if (response.attestationObject === undefined) {\n      throw new Error('Was expecting an attestation response.');\n    }\n\n    // Parse the attestationObject as CBOR.\n    const attObject = Cbor.decode<{ authData: Uint8Array }>(\n      new Uint8Array(response.attestationObject),\n    );\n\n    return new this(\n      uint8FromBufLike(creds.rawId),\n      _authDataToCose(attObject.authData),\n      creds.authenticatorAttachment ?? undefined,\n    );\n  }\n\n  protected _publicKey: CosePublicKey;\n\n  public constructor(\n    public readonly rawId: Uint8Array,\n    cose: Uint8Array,\n    protected authenticatorAttachment: AuthenticatorAttachment | undefined,\n  ) {\n    super();\n    this._publicKey = new CosePublicKey(cose);\n  }\n\n  public getPublicKey(): PublicKey {\n    return this._publicKey;\n  }\n\n  /**\n   * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n   * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n   * This attribute is already implemented for Chrome, Safari and Edge.\n   *\n   * Given the attribute is only available after a successful interaction, the information is\n   * provided opportunistically and might also be `undefined`.\n   */\n  public getAuthenticatorAttachment(): AuthenticatorAttachment | undefined {\n    return this.authenticatorAttachment;\n  }\n\n  public async sign(blob: Uint8Array): Promise<Signature> {\n    const result = (await navigator.credentials.get({\n      publicKey: {\n        allowCredentials: [\n          {\n            type: 'public-key',\n            id: this.rawId,\n          },\n        ],\n        challenge: blob,\n        userVerification: 'preferred',\n      },\n    })) as PublicKeyCredentialWithAttachment;\n\n    if (result.authenticatorAttachment !== null) {\n      this.authenticatorAttachment = result.authenticatorAttachment;\n    }\n\n    const response = result.response as AuthenticatorAssertionResponse;\n\n    const encoded = Cbor.encode({\n      authenticator_data: response.authenticatorData,\n      client_data_json: bytesToUtf8(new Uint8Array(response.clientDataJSON)),\n      signature: response.signature,\n    });\n\n    if (!encoded) {\n      throw new Error('failed to encode cbor');\n    }\n\n    Object.assign(encoded, {\n      __signature__: undefined,\n    });\n\n    return encoded as Signature;\n  }\n\n  /**\n   * Allow for JSON serialization of all information needed to reuse this identity.\n   */\n  public toJSON(): JsonnableWebAuthnIdentity {\n    return {\n      publicKey: bytesToHex(this._publicKey.getCose()),\n      rawId: bytesToHex(this.rawId),\n    };\n  }\n}\n\n/**\n * ReturnType<WebAuthnIdentity.toJSON>\n */\nexport interface JsonnableWebAuthnIdentity {\n  // The hexadecimal representation of the DER encoded public key.\n  publicKey: string;\n  // The string representation of the local WebAuthn Credential.id (base64url encoded).\n  rawId: string;\n}\n", "type IdleCB = () => unknown;\nexport type IdleManagerOptions = {\n  /**\n   * Callback after the user has gone idle\n   */\n  onIdle?: IdleCB;\n  /**\n   * timeout in ms\n   * @default 30 minutes [600_000]\n   */\n  idleTimeout?: number;\n  /**\n   * capture scroll events\n   * @default false\n   */\n  captureScroll?: boolean;\n  /**\n   * scroll debounce time in ms\n   * @default 100\n   */\n  scrollDebounce?: number;\n};\n\nconst events = ['mousedown', 'mousemove', 'keydown', 'touchstart', 'wheel'];\n\n/**\n * Detects if the user has been idle for a duration of `idleTimeout` ms, and calls `onIdle` and registered callbacks.\n * By default, the IdleManager will log a user out after 10 minutes of inactivity.\n * To override these defaults, you can pass an `onIdle` callback, or configure a custom `idleTimeout` in milliseconds\n */\nexport class IdleManager {\n  callbacks: IdleCB[] = [];\n  idleTimeout: IdleManagerOptions['idleTimeout'] = 10 * 60 * 1000;\n  timeoutID?: number = undefined;\n\n  /**\n   * Creates an {@link IdleManager}\n   * @param {IdleManagerOptions} options Optional configuration\n   * @see {@link IdleManagerOptions}\n   * @param options.onIdle Callback once user has been idle. Use to prompt for fresh login, and use `Actor.agentOf(your_actor).invalidateIdentity()` to protect the user\n   * @param options.idleTimeout timeout in ms\n   * @param options.captureScroll capture scroll events\n   * @param options.scrollDebounce scroll debounce time in ms\n   */\n  public static create(\n    options: {\n      /**\n       * Callback after the user has gone idle\n       * @see {@link IdleCB}\n       */\n      onIdle?: () => unknown;\n      /**\n       * timeout in ms\n       * @default 10 minutes [600_000]\n       */\n      idleTimeout?: number;\n      /**\n       * capture scroll events\n       * @default false\n       */\n      captureScroll?: boolean;\n      /**\n       * scroll debounce time in ms\n       * @default 100\n       */\n      scrollDebounce?: number;\n    } = {},\n  ): IdleManager {\n    return new this(options);\n  }\n\n  /**\n   * @protected\n   * @param options {@link IdleManagerOptions}\n   */\n  protected constructor(options: IdleManagerOptions = {}) {\n    const { onIdle, idleTimeout = 10 * 60 * 1000 } = options || {};\n\n    this.callbacks = onIdle ? [onIdle] : [];\n    this.idleTimeout = idleTimeout;\n\n    const _resetTimer = this._resetTimer.bind(this);\n\n    window.addEventListener('load', _resetTimer, true);\n\n    events.forEach(function (name) {\n      document.addEventListener(name, _resetTimer, true);\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    const debounce = (func: Function, wait: number) => {\n      let timeout: number | undefined;\n      return (...args: unknown[]) => {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const context = this;\n        const later = function () {\n          timeout = undefined;\n          func.apply(context, args);\n        };\n        clearTimeout(timeout);\n        timeout = window.setTimeout(later, wait);\n      };\n    };\n\n    if (options?.captureScroll) {\n      // debounce scroll events\n      const scroll = debounce(_resetTimer, options?.scrollDebounce ?? 100);\n      window.addEventListener('scroll', scroll, true);\n    }\n\n    _resetTimer();\n  }\n\n  /**\n   * @param {IdleCB} callback function to be called when user goes idle\n   */\n  public registerCallback(callback: IdleCB): void {\n    this.callbacks.push(callback);\n  }\n\n  /**\n   * Cleans up the idle manager and its listeners\n   */\n  public exit(): void {\n    clearTimeout(this.timeoutID);\n    window.removeEventListener('load', this._resetTimer, true);\n\n    const _resetTimer = this._resetTimer.bind(this);\n    events.forEach(function (name) {\n      document.removeEventListener(name, _resetTimer, true);\n    });\n    this.callbacks.forEach(cb => cb());\n  }\n\n  /**\n   * Resets the timeouts during cleanup\n   */\n  _resetTimer(): void {\n    const exit = this.exit.bind(this);\n    window.clearTimeout(this.timeoutID);\n    this.timeoutID = window.setTimeout(exit, this.idleTimeout);\n  }\n}\n", "const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n", "import { openDB, type IDBPDatabase } from 'idb';\nimport { DB_VERSION, isBrowser, KEY_STORAGE_DELEGATION, KEY_STORAGE_KEY } from './storage.ts';\n\ntype Database = IDBPDatabase<unknown>;\ntype IDBValidKey = string | number | Date | BufferSource | IDBValidKey[];\nconst AUTH_DB_NAME = 'auth-client-db';\nconst OBJECT_STORE_NAME = 'ic-keyval';\n\nconst _openDbStore = async (\n  dbName = AUTH_DB_NAME,\n  storeName = OBJECT_STORE_NAME,\n  version: number,\n) => {\n  // Clear legacy stored delegations\n  if (isBrowser && localStorage?.getItem(KEY_STORAGE_DELEGATION)) {\n    localStorage.removeItem(KEY_STORAGE_DELEGATION);\n    localStorage.removeItem(KEY_STORAGE_KEY);\n  }\n  return await openDB(dbName, version, {\n    upgrade: database => {\n      if (database.objectStoreNames.contains(storeName)) {\n        database.clear(storeName);\n      }\n      database.createObjectStore(storeName);\n    },\n  });\n};\n\nasync function _getValue<T>(\n  db: Database,\n  storeName: string,\n  key: IDBValidKey,\n): Promise<T | undefined> {\n  return await db.get(storeName, key);\n}\n\nasync function _setValue<T>(\n  db: Database,\n  storeName: string,\n  key: IDBValidKey,\n  value: T,\n): Promise<IDBValidKey> {\n  return await db.put(storeName, value, key);\n}\n\nasync function _removeValue(db: Database, storeName: string, key: IDBValidKey): Promise<void> {\n  return await db.delete(storeName, key);\n}\n\nexport type DBCreateOptions = {\n  dbName?: string;\n  storeName?: string;\n  version?: number;\n};\n\n/**\n * Simple Key Value store\n * Defaults to `'auth-client-db'` with an object store of `'ic-keyval'`\n */\nexport class IdbKeyVal {\n  /**\n   * @param {DBCreateOptions} options - DBCreateOptions\n   * @param {DBCreateOptions['dbName']} options.dbName name for the indexeddb database\n   * @default\n   * @param {DBCreateOptions['storeName']} options.storeName name for the indexeddb Data Store\n   * @default\n   * @param {DBCreateOptions['version']} options.version version of the database. Increment to safely upgrade\n   */\n  public static async create(options?: DBCreateOptions): Promise<IdbKeyVal> {\n    const {\n      dbName = AUTH_DB_NAME,\n      storeName = OBJECT_STORE_NAME,\n      version = DB_VERSION,\n    } = options ?? {};\n    const db = await _openDbStore(dbName, storeName, version);\n    return new IdbKeyVal(db, storeName);\n  }\n\n  // Do not use - instead prefer create\n  private constructor(\n    private _db: Database,\n    private _storeName: string,\n  ) {}\n\n  /**\n   * Basic setter\n   * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]\n   * @param value value to set\n   * @returns void\n   */\n  public async set<T>(key: IDBValidKey, value: T) {\n    return await _setValue<T>(this._db, this._storeName, key, value);\n  }\n  /**\n   * Basic getter\n   * Pass in a type T for type safety if you know the type the value will have if it is found\n   * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]\n   * @returns `Promise<T | null>`\n   * @example\n   * await get<string>('exampleKey') -> 'exampleValue'\n   */\n  public async get<T>(key: IDBValidKey): Promise<T | null> {\n    return (await _getValue<T>(this._db, this._storeName, key)) ?? null;\n  }\n\n  /**\n   * Remove a key\n   * @param key {@link IDBValidKey}\n   * @returns void\n   */\n  public async remove(key: IDBValidKey) {\n    return await _removeValue(this._db, this._storeName, key);\n  }\n}\n", "import { type DBCreateOptions, IdbKeyVal } from './db.ts';\n\nexport const KEY_STORAGE_KEY = 'identity';\nexport const KEY_STORAGE_DELEGATION = 'delegation';\nexport const KEY_VECTOR = 'iv';\n// Increment if any fields are modified\nexport const DB_VERSION = 1;\n\nexport const isBrowser = typeof window !== 'undefined';\n\nexport type StoredKey = string | CryptoKeyPair;\n\n/**\n * Interface for persisting user authentication data\n */\nexport interface AuthClientStorage {\n  get(key: string): Promise<StoredKey | null>;\n\n  set(key: string, value: StoredKey): Promise<void>;\n\n  remove(key: string): Promise<void>;\n}\n\n/**\n * Legacy implementation of AuthClientStorage, for use where IndexedDb is not available\n */\nexport class LocalStorage implements AuthClientStorage {\n  constructor(\n    public readonly prefix = 'ic-',\n    private readonly _localStorage?: Storage,\n  ) {}\n\n  public get(key: string): Promise<string | null> {\n    return Promise.resolve(this._getLocalStorage().getItem(this.prefix + key));\n  }\n\n  public set(key: string, value: string): Promise<void> {\n    this._getLocalStorage().setItem(this.prefix + key, value);\n    return Promise.resolve();\n  }\n\n  public remove(key: string): Promise<void> {\n    this._getLocalStorage().removeItem(this.prefix + key);\n    return Promise.resolve();\n  }\n\n  private _getLocalStorage() {\n    if (this._localStorage) {\n      return this._localStorage;\n    }\n\n    const ls =\n      typeof window === 'undefined'\n        ? typeof global === 'undefined'\n          ? typeof self === 'undefined'\n            ? undefined\n            : self.localStorage\n          : global.localStorage\n        : window.localStorage;\n\n    if (!ls) {\n      throw new Error('Could not find local storage.');\n    }\n\n    return ls;\n  }\n}\n\n/**\n * IdbStorage is an interface for simple storage of string key-value pairs built on {@link IdbKeyVal}\n *\n * It replaces {@link LocalStorage}\n * @see implements {@link AuthClientStorage}\n */\nexport class IdbStorage implements AuthClientStorage {\n  #options: DBCreateOptions;\n\n  /**\n   * @param options - DBCreateOptions\n   * @param options.dbName - name for the indexeddb database\n   * @param options.storeName - name for the indexeddb Data Store\n   * @param options.version - version of the database. Increment to safely upgrade\n   * @example\n   * ```ts\n   * const storage = new IdbStorage({ dbName: 'my-db', storeName: 'my-store', version: 2 });\n   * ```\n   */\n  constructor(options?: DBCreateOptions) {\n    this.#options = options ?? {};\n  }\n\n  // Initializes a KeyVal on first request\n  private initializedDb: IdbKeyVal | undefined;\n  get _db(): Promise<IdbKeyVal> {\n    return new Promise((resolve, reject) => {\n      if (this.initializedDb) {\n        resolve(this.initializedDb);\n        return;\n      }\n      IdbKeyVal.create(this.#options)\n        .then(db => {\n          this.initializedDb = db;\n          resolve(db);\n        })\n        .catch(reject);\n    });\n  }\n\n  public async get<T = string>(key: string): Promise<T | null> {\n    const db = await this._db;\n    return await db.get<T>(key);\n  }\n\n  public async set<T = string>(key: string, value: T): Promise<void> {\n    const db = await this._db;\n    await db.set(key, value);\n  }\n\n  public async remove(key: string): Promise<void> {\n    const db = await this._db;\n    await db.remove(key);\n  }\n}\n", "import {\n  AnonymousIdentity,\n  type DerEncodedPublicKey,\n  type Identity,\n  type Signature,\n  SignIdentity,\n} from '@dfinity/agent';\nimport {\n  Delegation,\n  DelegationChain,\n  isDelegationValid,\n  DelegationIdentity,\n  Ed25519KeyIdentity,\n  ECDSAKeyIdentity,\n  PartialDelegationIdentity,\n  PartialIdentity,\n} from '@dfinity/identity';\nimport { Principal } from '@dfinity/principal';\nimport { IdleManager, type IdleManagerOptions } from './idleManager.ts';\nimport {\n  type AuthClientStorage,\n  IdbStorage,\n  isBrowser,\n  KEY_STORAGE_DELEGATION,\n  KEY_STORAGE_KEY,\n  KEY_VECTOR,\n  LocalStorage,\n} from './storage.ts';\n\nexport {\n  type AuthClientStorage,\n  IdbStorage,\n  LocalStorage,\n  KEY_STORAGE_DELEGATION,\n  KEY_STORAGE_KEY,\n} from './storage.ts';\nexport { IdbKeyVal, type DBCreateOptions } from './db.ts';\n\nconst NANOSECONDS_PER_SECOND = BigInt(1_000_000_000);\nconst SECONDS_PER_HOUR = BigInt(3_600);\nconst NANOSECONDS_PER_HOUR = NANOSECONDS_PER_SECOND * SECONDS_PER_HOUR;\n\nconst IDENTITY_PROVIDER_DEFAULT = 'https://identity.internetcomputer.org';\nconst IDENTITY_PROVIDER_ENDPOINT = '#authorize';\n\nconst DEFAULT_MAX_TIME_TO_LIVE = BigInt(8) * NANOSECONDS_PER_HOUR;\n\nconst ECDSA_KEY_LABEL = 'ECDSA';\nconst ED25519_KEY_LABEL = 'Ed25519';\ntype BaseKeyType = typeof ECDSA_KEY_LABEL | typeof ED25519_KEY_LABEL;\n\nconst INTERRUPT_CHECK_INTERVAL = 500;\n\nexport const ERROR_USER_INTERRUPT = 'UserInterrupt';\n\n/**\n * List of options for creating an {@link AuthClient}.\n */\nexport interface AuthClientCreateOptions {\n  /**\n   * An {@link SignIdentity} or {@link PartialIdentity} to authenticate via delegation.\n   */\n  identity?: SignIdentity | PartialIdentity;\n  /**\n   * Optional storage with get, set, and remove. Uses {@link IdbStorage} by default.\n   * @see {@link AuthClientStorage}\n   */\n  storage?: AuthClientStorage;\n\n  /**\n   * Type to use for the base key.\n   *\n   * If you are using a custom storage provider that does not support CryptoKey storage,\n   * you should use `Ed25519` as the key type, as it can serialize to a string.\n   * @default 'ECDSA'\n   */\n  keyType?: BaseKeyType;\n\n  /**\n   * Options to handle idle timeouts\n   * @default after 10 minutes, invalidates the identity\n   */\n  idleOptions?: IdleOptions;\n\n  /**\n   * Options to handle login, passed to the login method\n   */\n  loginOptions?: AuthClientLoginOptions;\n}\n\nexport interface IdleOptions extends IdleManagerOptions {\n  /**\n   * Disables idle functionality for {@link IdleManager}\n   * @default false\n   */\n  disableIdle?: boolean;\n\n  /**\n   * Disables default idle behavior - call logout & reload window\n   * @default false\n   */\n  disableDefaultIdleCallback?: boolean;\n}\n\nexport * from './idleManager.ts';\n\nexport type OnSuccessFunc =\n  | (() => void | Promise<void>)\n  | ((message: InternetIdentityAuthResponseSuccess) => void | Promise<void>);\n\nexport type OnErrorFunc = (error?: string) => void | Promise<void>;\n\nexport interface AuthClientLoginOptions {\n  /**\n   * Identity provider\n   * @default \"https://identity.internetcomputer.org\"\n   */\n  identityProvider?: string | URL;\n  /**\n   * Expiration of the authentication in nanoseconds\n   * @default  BigInt(8) hours * BigInt(3_600_000_000_000) nanoseconds\n   */\n  maxTimeToLive?: bigint;\n  /**\n   * If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   */\n  allowPinAuthentication?: boolean;\n  /**\n   * Origin for Identity Provider to use while generating the delegated identity. For II, the derivation origin must authorize this origin by setting a record at `<derivation-origin>/.well-known/ii-alternative-origins`.\n   * @see https://github.com/dfinity/internet-identity/blob/main/docs/internet-identity-spec.adoc\n   */\n  derivationOrigin?: string | URL;\n  /**\n   * Auth Window feature config string\n   * @example \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\"\n   */\n  windowOpenerFeatures?: string;\n  /**\n   * Callback once login has completed\n   */\n  onSuccess?: OnSuccessFunc;\n  /**\n   * Callback in case authentication fails\n   */\n  onError?: OnErrorFunc;\n  /**\n   * Extra values to be passed in the login request during the authorize-ready phase\n   */\n  customValues?: Record<string, unknown>;\n}\n\ninterface InternetIdentityAuthRequest {\n  kind: 'authorize-client';\n  sessionPublicKey: Uint8Array;\n  maxTimeToLive?: bigint;\n  allowPinAuthentication?: boolean;\n  derivationOrigin?: string;\n}\n\nexport interface InternetIdentityAuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n  authnMethod: 'passkey' | 'pin' | 'recovery';\n}\n\ninterface AuthReadyMessage {\n  kind: 'authorize-ready';\n}\n\ninterface AuthResponseSuccess {\n  kind: 'authorize-client-success';\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: Principal[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n  authnMethod: 'passkey' | 'pin' | 'recovery';\n}\n\ninterface AuthResponseFailure {\n  kind: 'authorize-client-failure';\n  text: string;\n}\n\ntype IdentityServiceResponseMessage = AuthReadyMessage | AuthResponse;\ntype AuthResponse = AuthResponseSuccess | AuthResponseFailure;\n\n/**\n * Tool to manage authentication and identity\n * @see {@link AuthClient}\n */\nexport class AuthClient {\n  /**\n   * Create an AuthClient to manage authentication and identity\n   * @param {AuthClientCreateOptions} options - Options for creating an {@link AuthClient}\n   * @see {@link AuthClientCreateOptions}\n   * @param options.identity Optional Identity to use as the base\n   * @see {@link SignIdentity}\n   * @param options.storage Storage mechanism for delegation credentials\n   * @see {@link AuthClientStorage}\n   * @param options.keyType Type of key to use for the base key\n   * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}\n   * @see {@link IdleOptions}\n   * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.\n   * @example\n   * const authClient = await AuthClient.create({\n   *   idleOptions: {\n   *     disableIdle: true\n   *   }\n   * })\n   */\n  public static async create(options: AuthClientCreateOptions = {}): Promise<AuthClient> {\n    const storage = options.storage ?? new IdbStorage();\n    const keyType = options.keyType ?? ECDSA_KEY_LABEL;\n\n    let key: null | SignIdentity | PartialIdentity = null;\n    if (options.identity) {\n      key = options.identity;\n    } else {\n      let maybeIdentityStorage = await storage.get(KEY_STORAGE_KEY);\n      if (!maybeIdentityStorage && isBrowser) {\n        // Attempt to migrate from localstorage\n        try {\n          const fallbackLocalStorage = new LocalStorage();\n          const localChain = await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION);\n          const localKey = await fallbackLocalStorage.get(KEY_STORAGE_KEY);\n          // not relevant for Ed25519\n          if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {\n            console.log('Discovered an identity stored in localstorage. Migrating to IndexedDB');\n            await storage.set(KEY_STORAGE_DELEGATION, localChain);\n            await storage.set(KEY_STORAGE_KEY, localKey);\n\n            maybeIdentityStorage = localChain;\n            // clean up\n            await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION);\n            await fallbackLocalStorage.remove(KEY_STORAGE_KEY);\n          }\n        } catch (error) {\n          console.error('error while attempting to recover localstorage: ' + error);\n        }\n      }\n      if (maybeIdentityStorage) {\n        try {\n          if (typeof maybeIdentityStorage === 'object') {\n            if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === 'string') {\n              key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n            } else {\n              key = await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);\n            }\n          } else if (typeof maybeIdentityStorage === 'string') {\n            // This is a legacy identity, which is a serialized Ed25519KeyIdentity.\n            key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n          }\n        } catch {\n          // Ignore this, this means that the localStorage value isn't a valid Ed25519KeyIdentity or ECDSAKeyIdentity\n          // serialization.\n        }\n      }\n    }\n\n    let identity: SignIdentity | PartialIdentity = new AnonymousIdentity() as PartialIdentity;\n    let chain: null | DelegationChain = null;\n    if (key) {\n      try {\n        const chainStorage = await storage.get(KEY_STORAGE_DELEGATION);\n        if (typeof chainStorage === 'object' && chainStorage !== null) {\n          throw new Error(\n            'Delegation chain is incorrectly stored. A delegation chain should be stored as a string.',\n          );\n        }\n\n        if (options.identity) {\n          identity = options.identity;\n        } else if (chainStorage) {\n          chain = DelegationChain.fromJSON(chainStorage);\n\n          // Verify that the delegation isn't expired.\n          if (!isDelegationValid(chain)) {\n            await _deleteStorage(storage);\n            key = null;\n          } else {\n            // If the key is a public key, then we create a PartialDelegationIdentity.\n            if ('toDer' in key) {\n              identity = PartialDelegationIdentity.fromDelegation(key, chain);\n              // otherwise, we create a DelegationIdentity.\n            } else {\n              identity = DelegationIdentity.fromDelegation(key, chain);\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        // If there was a problem loading the chain, delete the key.\n        await _deleteStorage(storage);\n        key = null;\n      }\n    }\n    let idleManager: IdleManager | undefined;\n    if (options.idleOptions?.disableIdle) {\n      idleManager = undefined;\n    }\n    // if there is a delegation chain or provided identity, setup idleManager\n    else if (chain || options.identity) {\n      idleManager = IdleManager.create(options.idleOptions);\n    }\n\n    if (!key) {\n      // Create a new key (whether or not one was in storage).\n      if (keyType === ED25519_KEY_LABEL) {\n        key = Ed25519KeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, JSON.stringify((key as Ed25519KeyIdentity).toJSON()));\n      } else {\n        if (options.storage && keyType === ECDSA_KEY_LABEL) {\n          console.warn(\n            `You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`,\n          );\n        }\n        key = await ECDSAKeyIdentity.generate();\n        await storage.set(KEY_STORAGE_KEY, (key as ECDSAKeyIdentity).getKeyPair());\n      }\n    }\n\n    return new this(identity, key, chain, storage, idleManager, options);\n  }\n\n  protected constructor(\n    private _identity: Identity | PartialIdentity,\n    private _key: SignIdentity | PartialIdentity,\n    private _chain: DelegationChain | null,\n    private _storage: AuthClientStorage,\n    public idleManager: IdleManager | undefined,\n    private _createOptions: AuthClientCreateOptions | undefined,\n    // A handle on the IdP window.\n    private _idpWindow?: Window,\n    // The event handler for processing events from the IdP.\n    private _eventHandler?: (event: MessageEvent) => void,\n  ) {\n    this._registerDefaultIdleCallback();\n  }\n\n  private _registerDefaultIdleCallback() {\n    const idleOptions = this._createOptions?.idleOptions;\n    /**\n     * Default behavior is to clear stored identity and reload the page.\n     * By either setting the disableDefaultIdleCallback flag or passing in a custom idle callback, we will ignore this config\n     */\n    if (!idleOptions?.onIdle && !idleOptions?.disableDefaultIdleCallback) {\n      this.idleManager?.registerCallback(() => {\n        this.logout();\n        location.reload();\n      });\n    }\n  }\n\n  private async _handleSuccess(\n    message: InternetIdentityAuthResponseSuccess,\n    onSuccess?: OnSuccessFunc,\n  ) {\n    const delegations = message.delegations.map(signedDelegation => {\n      return {\n        delegation: new Delegation(\n          signedDelegation.delegation.pubkey,\n          signedDelegation.delegation.expiration,\n          signedDelegation.delegation.targets,\n        ),\n        signature: signedDelegation.signature as Signature,\n      };\n    });\n\n    const delegationChain = DelegationChain.fromDelegations(\n      delegations,\n      message.userPublicKey as DerEncodedPublicKey,\n    );\n\n    const key = this._key;\n    if (!key) {\n      return;\n    }\n\n    this._chain = delegationChain;\n\n    if ('toDer' in key) {\n      this._identity = PartialDelegationIdentity.fromDelegation(key, this._chain);\n    } else {\n      this._identity = DelegationIdentity.fromDelegation(key, this._chain);\n    }\n\n    this._idpWindow?.close();\n    const idleOptions = this._createOptions?.idleOptions;\n    // create the idle manager on a successful login if we haven't disabled it\n    // and it doesn't already exist.\n    if (!this.idleManager && !idleOptions?.disableIdle) {\n      this.idleManager = IdleManager.create(idleOptions);\n      this._registerDefaultIdleCallback();\n    }\n\n    this._removeEventListener();\n    delete this._idpWindow;\n\n    if (this._chain) {\n      await this._storage.set(KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));\n    }\n\n    // onSuccess should be the last thing to do to avoid consumers\n    // interfering by navigating or refreshing the page\n    onSuccess?.(message);\n  }\n\n  public getIdentity(): Identity {\n    return this._identity;\n  }\n\n  public async isAuthenticated(): Promise<boolean> {\n    return (\n      !this.getIdentity().getPrincipal().isAnonymous() &&\n      this._chain !== null &&\n      isDelegationValid(this._chain)\n    );\n  }\n\n  /**\n   * AuthClient Login - Opens up a new window to authenticate with Internet Identity\n   * @param {AuthClientLoginOptions} options - Options for logging in, merged with the options set during creation if any. Note: we only perform a shallow merge for the `customValues` property.\n   * @param options.identityProvider Identity provider\n   * @param options.maxTimeToLive Expiration of the authentication in nanoseconds\n   * @param options.allowPinAuthentication If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).\n   * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity\n   * @param options.windowOpenerFeatures Configures the opened authentication window\n   * @param options.onSuccess Callback once login has completed\n   * @param options.onError Callback in case authentication fails\n   * @param options.customValues Extra values to be passed in the login request during the authorize-ready phase. Note: we only perform a shallow merge for the `customValues` property.\n   * @example\n   * const authClient = await AuthClient.create();\n   * authClient.login({\n   *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',\n   *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week\n   *  windowOpenerFeatures: \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\",\n   *  onSuccess: () => {\n   *    console.log('Login Successful!');\n   *  },\n   *  onError: (error) => {\n   *    console.error('Login Failed: ', error);\n   *  }\n   * });\n   */\n  public async login(options?: AuthClientLoginOptions): Promise<void> {\n    // Merge the passed options with the options set during creation\n    const loginOptions = mergeLoginOptions(this._createOptions?.loginOptions, options);\n\n    // Set default maxTimeToLive to 8 hours\n    const maxTimeToLive = loginOptions?.maxTimeToLive ?? DEFAULT_MAX_TIME_TO_LIVE;\n\n    // Create the URL of the IDP. (e.g. https://XXXX/#authorize)\n    const identityProviderUrl = new URL(\n      loginOptions?.identityProvider?.toString() || IDENTITY_PROVIDER_DEFAULT,\n    );\n    // Set the correct hash if it isn't already set.\n    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;\n\n    // If `login` has been called previously, then close/remove any previous windows\n    // and event listeners.\n    this._idpWindow?.close();\n    this._removeEventListener();\n\n    // Add an event listener to handle responses.\n    this._eventHandler = this._getEventHandler(identityProviderUrl, {\n      maxTimeToLive,\n      ...loginOptions,\n    });\n    window.addEventListener('message', this._eventHandler);\n\n    // Open a new window with the IDP provider.\n    this._idpWindow =\n      window.open(\n        identityProviderUrl.toString(),\n        'idpWindow',\n        loginOptions?.windowOpenerFeatures,\n      ) ?? undefined;\n\n    // Check if the _idpWindow is closed by user.\n    const checkInterruption = (): void => {\n      // The _idpWindow is opened and not yet closed by the client\n      if (this._idpWindow) {\n        if (this._idpWindow.closed) {\n          this._handleFailure(ERROR_USER_INTERRUPT, loginOptions?.onError);\n        } else {\n          setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);\n        }\n      }\n    };\n    checkInterruption();\n  }\n\n  private _getEventHandler(identityProviderUrl: URL, options?: AuthClientLoginOptions) {\n    return async (event: MessageEvent) => {\n      if (event.origin !== identityProviderUrl.origin) {\n        // Ignore any event that is not from the identity provider\n        return;\n      }\n\n      const message = event.data as IdentityServiceResponseMessage;\n\n      switch (message.kind) {\n        case 'authorize-ready': {\n          // IDP is ready. Send a message to request authorization.\n          const request: InternetIdentityAuthRequest = {\n            kind: 'authorize-client',\n            sessionPublicKey: new Uint8Array(this._key?.getPublicKey().toDer()),\n            maxTimeToLive: options?.maxTimeToLive,\n            allowPinAuthentication: options?.allowPinAuthentication,\n            derivationOrigin: options?.derivationOrigin?.toString(),\n            // Pass any custom values to the IDP.\n            ...options?.customValues,\n          };\n          this._idpWindow?.postMessage(request, identityProviderUrl.origin);\n          break;\n        }\n        case 'authorize-client-success':\n          // Create the delegation chain and store it.\n          try {\n            await this._handleSuccess(message, options?.onSuccess);\n          } catch (err) {\n            this._handleFailure((err as Error).message, options?.onError);\n          }\n          break;\n        case 'authorize-client-failure':\n          this._handleFailure(message.text, options?.onError);\n          break;\n        default:\n          break;\n      }\n    };\n  }\n\n  private _handleFailure(errorMessage?: string, onError?: (error?: string) => void): void {\n    this._idpWindow?.close();\n    onError?.(errorMessage);\n    this._removeEventListener();\n    delete this._idpWindow;\n  }\n\n  private _removeEventListener() {\n    if (this._eventHandler) {\n      window.removeEventListener('message', this._eventHandler);\n    }\n    this._eventHandler = undefined;\n  }\n\n  public async logout(options: { returnTo?: string } = {}): Promise<void> {\n    await _deleteStorage(this._storage);\n\n    // Reset this auth client to a non-authenticated state.\n    this._identity = new AnonymousIdentity();\n    this._chain = null;\n\n    if (options.returnTo) {\n      try {\n        window.history.pushState({}, '', options.returnTo);\n      } catch {\n        window.location.href = options.returnTo;\n      }\n    }\n  }\n}\n\nasync function _deleteStorage(storage: AuthClientStorage) {\n  await storage.remove(KEY_STORAGE_KEY);\n  await storage.remove(KEY_STORAGE_DELEGATION);\n  await storage.remove(KEY_VECTOR);\n}\n\nfunction mergeLoginOptions(\n  loginOptions: AuthClientLoginOptions | undefined,\n  otherLoginOptions: AuthClientLoginOptions | undefined,\n): AuthClientLoginOptions | undefined {\n  if (!loginOptions && !otherLoginOptions) {\n    return undefined;\n  }\n\n  const customValues =\n    loginOptions?.customValues || otherLoginOptions?.customValues\n      ? {\n          ...loginOptions?.customValues,\n          ...otherLoginOptions?.customValues,\n        }\n      : undefined;\n\n  return {\n    ...loginOptions,\n    ...otherLoginOptions,\n    customValues,\n  };\n}\n"],
  "mappings": "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",
  "names": ["_inner", "_delegation", "PubKeyCoseAlgo", "target"]
}
